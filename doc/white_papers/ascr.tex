\documentclass[12pt]{article}
\textwidth=7in
\textheight=9.5in
\topmargin=-1in
\headheight=0in
\headsep=.5in
\hoffset  -.85in

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{setspace}
\usepackage{array}
\usepackage{hyperref}


\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\pagestyle{empty}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\begin{document}

\textbf{\\Exascale ray tracing; a white paper}\\

\textbf {\\ Introduction} \\

Scaling applications to exascale is a task that will take significant programming effort.  The extent of that effort has been explored as part of the Traleika Glacier X-Stack project funded under Department of Energy Award Number DE-SC0008717.  Conclusions from that project suggest that at exascale we will see a shift in programming models away from traditional “machine-level” parallel computing models, such as MPI or MPI+OpemMP, and towards a high level task based programming models that relies more heavily on the runtime for optimization.  We are currently looking at the implications of this shift in a ray tracing algorithm. \\

Ray tracing is a common algorithm used to produce realistic visualizations of data.  The core path tracing algorithm can also be extended to particle system applications.  Just focusing on the visualization aspect, we see ray tracing libraries developed as plugins for core HPC visualization tools such as VisIt and ParaView.  Manta developed at the University of Utah and pvOSPRay developed by the Texas Advanced Computing Center are two commonly used plugins.  Both of these plugins work on current distributed systems but based on the algorithm design will not scale to exascale.

\textbf {\\ Proposed effort} \\

We propose the development of a generic task based ray tracer that will run on both todays hardware and tomorrows exascale machines, this module can then be integrated into any visualization software of a user’s choosing.

\textbf {\\ Solution} \\

We propose the development of a generic task based ray tracer that will run on today’s hardware as well as tomorrows exascale machines, this module can then be integrated into any visualization software of a user’s choosing. 

\textbf {\\ Phase 1: implementation} \\

As ray tracing in general is not a new field we will implement a system that takes advantage of existing highly optimized ray tracing engines.  We will integrate first with Intel’s ray tracing library, Embree, this is the same kernel being used by pvOSPRay and has been optimized for several intel chips including Xeon Phi.  Future work may include integrating with OptiX, NVidia’s ray tracing kernel to run on GPUs as well as extending the algorithm to dynamically choose at runtime which library or libraries to used based on the current runtime system.

\textbf {\\ Phase 2: adapting to task based systems} \\

As with other applications, the shift towards exascale will take us towards task based programming models and change the underlying hardware.  This has implications on ray tracing and is what we will explore in the second phase of our work.  For example, many existing distributed ray tracers work by duplicating input data across nodes.  As the size of memory per node is projected to decline significantly at exascale, this key design assumption will hinder current algorithms performance.  We will therefore redesign the current algorithms and implement a solution using Intel CnC, a task based model, that will perform on today’s architecture as well as next generation.  

\textbf {\\ Phase 3: library extensions} \\

With the base system in place we then plan to extend our work in two key ways; optimizing performance and increasing impact.  On many proposed task based programming models, including CnC, a separate input file can be provided to the runtime to provide hints for scheduling and data movement to increase performance.  We would like to implement and test this tuning specification on different systems to determine the usefulness and necessity for ray tracing algorithms.  Finally we would like to extend our work towards more ray tracing functionality such as global illumination, support for multiple displays, and virtual reality headsets.

\textbf {\\ Conclusion} \\

We hope that with the coming of exascale, full ray tracing and full global illumination of large data sets will be efficient enough to be used for everyday data visualization.  Although we do not have exascale architectures available yet, we propose to produce a model that will work sufficiently at on today’s distributed systems as well as future systems.

\end{document}